<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Pooshit.Scripting</name>
    </assembly>
    <members>
        <member name="T:Pooshit.Scripting.Control.Break">
            <summary>
            breaks execution of a loop
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Break.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Break"/>
            </summary>
            <param name="depth">depth to break</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Break.Depth">
            <summary>
            number of loops to break with this statement
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Break.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Break.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Break.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Break.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Case">
            <summary>
            case for a <see cref="T:Pooshit.Scripting.Control.Switch"/> statement
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Case.#ctor">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Case"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Case.#ctor(Pooshit.Scripting.Tokens.IScriptToken[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Case"/>
            </summary>
            <param name="conditions">conditions to match</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Case.IsDefault">
            <summary>
            determines whether this is the default case
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Case.Matches(System.Object,Pooshit.Scripting.ScriptContext)">
            <summary>
            determines whether case matches a value
            </summary>
            <param name="value">value to match</param>
            <param name="context">script execution context</param>
            <returns>true if case matches value, false otherwise</returns>
        </member>
        <member name="P:Pooshit.Scripting.Control.Case.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Case.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Case.Body">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Case.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Case.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Case.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Catch">
            <summary>
            token containing body for a <see cref="T:Pooshit.Scripting.Control.Try"/> statement when an exception is catched
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Catch.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Catch.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Catch.Body">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Catch.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Continue">
            <summary>
            breaks execution of a loop
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Continue.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Break"/>
            </summary>
            <param name="depth">loop depth to continue</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Continue.Depth">
            <summary>
            specifies the depth of continue statement
            </summary>
            <remarks>
            a depth of 2 means that the current loop ended the the outer loop is continued instead
            </remarks>
        </member>
        <member name="P:Pooshit.Scripting.Control.Continue.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Continue.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Continue.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Continue.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.ControlToken">
            <summary>
            token representing a control structure
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.ControlToken.Body">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Else">
            <summary>
            token containing body for an <see cref="T:Pooshit.Scripting.Control.If"/> statement of which condition is not met
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Else.#ctor">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Else"/>
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Else.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Else.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Else.Body">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Else.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.For">
            <summary>
            loop with an initializer, a condition and an increment
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.For.#ctor(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.For"/> statement 
            </summary>
            <param name="initializer">variable initializer</param>
            <param name="condition">loop condition</param>
            <param name="step">loop step token</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.For.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.For.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.For.Body">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.For.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.For.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.For.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Foreach">
            <summary>
            loop which iterates over a collection
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Foreach.#ctor(Pooshit.Scripting.Tokens.ScriptVariable,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Foreach"/>
            </summary>
            <param name="variable">iterator variable</param>
            <param name="collection">collection which is enumerated</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Foreach.Iterator">
            <summary>
            iterator variable
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Foreach.Collection">
            <summary>
            collection to be iterated
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Foreach.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Foreach.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Foreach.Body">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Foreach.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Foreach.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Foreach.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.If">
            <summary>
            statement execution a body when a condition is met
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.If.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.If"/> statement
            </summary>
            <param name="condition">condition statement has to match to execute body</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.If.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.If.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.If.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.If.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.If.Body">
            <summary>
            body to execute if condition is met
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.If.Else">
            <summary>
            body to execute when condition is not met
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.If.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Import">
            <summary>
            imports a script method using the <see cref="T:Pooshit.Scripting.Providers.IImportProvider"/> of the parser
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Import.#ctor(Pooshit.Scripting.Providers.IImportProvider,Pooshit.Scripting.Tokens.IScriptToken[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Import"/>
            </summary>
            <param name="methodprovider"></param>
            <param name="key"></param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Import.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Import.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Import.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Import.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.IStatementContainer">
            <summary>
            token representing a flow control statement
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.IStatementContainer.Body">
            <summary>
            body of control statement
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Control.ITokenContainer">
            <summary>
            block containing several statement tokens
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.ITokenContainer.Children">
            <summary>
            tokens contained in the container
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Control.ParserToken">
            <summary>
            token containing meta information for parsing process
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.ParserToken.#ctor(System.String)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.ParserToken"/>
            </summary>
            <param name="data">data specifying parser case</param>
        </member>
        <member name="T:Pooshit.Scripting.Control.Return">
            <summary>
            returns a value and end execution of current method
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Return.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Return"/>
            </summary>
            <param name="value">token to return</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Return.Value">
            <summary>
            token resulting in value to return
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Return.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Return.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Return.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Return.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Return.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.StatementBlock">
            <summary>
            a block of statements executed in sequence
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.StatementBlock.#ctor(Pooshit.Scripting.Tokens.IScriptToken[],System.Boolean)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.StatementBlock"/>
            </summary>
            <param name="statements">statements in block</param>
            <param name="methodblock">determines whether this is the main block of a method</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.StatementBlock.Children">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.StatementBlock.Literal">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.StatementBlock.MethodBlock">
            <summary>
            determines whether block is a method block
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.StatementBlock.Execute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.StatementBlock.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.StatementBlock.LineNumber">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.StatementBlock.TextIndex">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.StatementBlock.TokenLength">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Switch">
            <summary>
            evaluates a value and jumps to matching cases
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Switch.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Switch"/> statement
            </summary>
            <param name="condition">value to evaluate</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Switch.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Switch.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Switch.Cases">
            <summary>
            cases for switch branch
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Switch.Default">
            <summary>
            default case executed if no other case matches
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Switch.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Switch.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Switch.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Switch.Body">
            <summary>
            a body is not used for switch statements
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Control.Throw">
            <summary>
            throws an exception from currently executed code
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Throw.#ctor(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Throw"/>
            </summary>
            <param name="message">exception message</param>
            <param name="context">context data for exception</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Throw.Message">
            <summary>
            exception message
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Throw.Context">
            <summary>
            exception context
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Throw.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Throw.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Throw.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Try">
            <summary>
            statement wrapping a body for exception handling
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Try.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Try.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Try.Body">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Try.Catch">
            <summary>
            body to execute when condition is not met
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Try.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Using">
            <summary>
            block which handles a disposable resource
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Using.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Using.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Using.Body">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Using.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Using.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.Using.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.Wait">
            <summary>
            token which waits a specified timespan
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.Wait.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.Wait"/>
            </summary>
            <param name="time">time to wait</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.Wait.Time">
            <summary>
            time to wait
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Control.Wait.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.Wait.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Control.While">
            <summary>
            executes a statement block while a condition is met
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Control.While.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Control.While"/>
            </summary>
            <param name="condition">condition to check</param>
        </member>
        <member name="P:Pooshit.Scripting.Control.While.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Control.While.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.While.Body">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.While.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Control.While.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Data.ExternalScriptMethod">
            <summary>
            script method provided by resolver
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Data.ExternalScriptMethod.#ctor(Pooshit.Scripting.IScript)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Data.ExternalScriptMethod"/>
            </summary>
            <param name="script"></param>
        </member>
        <member name="M:Pooshit.Scripting.Data.ExternalScriptMethod.Invoke(Pooshit.Scripting.Parser.IVariableProvider,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Data.ExternalScriptMethod.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Data.IExternalMethod">
            <summary>
            interface for an external method which can get called from a script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Data.IExternalMethod.Invoke(Pooshit.Scripting.Parser.IVariableProvider,System.Object[])">
            <summary>
            invokes the method with the specified arguments
            </summary>
            <param name="variables">variables of calling script</param>
            <param name="arguments">arguments for script method</param>
            <returns>result of script execution</returns>
        </member>
        <member name="T:Pooshit.Scripting.Data.Operator">
            <summary>
            operator type
            </summary>
            <remarks>
            the order in this enumeration is used for operator priority
            </remarks>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Not">
            <summary>
            Negates a boolean value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Negate">
            <summary>
            negates an arithmetic value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Complement">
            <summary>
            Flips every bit of a numerical value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Increment">
            <summary>
            Increments the token this operator is attached to by 1
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Decrement">
            <summary>
            Decrements the token this operator is attached to by 1
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Division">
            <summary>
            Divides the left hand side value by the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Multiplication">
            <summary>
            Multiplies the left hand side value by the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Modulo">
            <summary>
            Computes the remainder when dividing the left hand side value by the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Subtraction">
            <summary>
            Subtracts the right hand side value from the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Addition">
            <summary>
            Adds left hand side and right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Less">
            <summary>
            Determines whether the left hand side value is less than the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.LessOrEqual">
            <summary>
            Determines whether the left hand side value is less than or equal to the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Greater">
            <summary>
            Determines whether the left hand side value is greater than the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.GreaterOrEqual">
            <summary>
            Determines whether the left hand side value is greater than or equal to the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Equal">
            <summary>
            Determines whether the left hand side is equal to the right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.NotEqual">
            <summary>
            Not Equals|Determines whether the left hand side is not equal to the right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Matches">
            <summary>
            Determines whether the left hand side value matches the regex pattern on the right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.NotMatches">
            <summary>
            Determines whether the left hand side value does not match the regex pattern of the right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.BitwiseAnd">
            <summary>
            Applies a bitwise and between left hand side and right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.BitwiseOr">
            <summary>
            Applies a bitwise or between left hand side and right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.BitwiseXor">
            <summary>
            Applies a bitwise xor between left hand side and right hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.ShiftLeft">
            <summary>
            Shifts left the bits of the left hand side value by the number of steps specified by the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.ShiftRight">
            <summary>
            Shifts right the bits of the left hand side value by the number of steps specified by the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.RolLeft">
            <summary>
            Rolls left the bits of the left hand side value by the number of steps specified by the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.RolRight">
            <summary>
            Rolls right the bits of the left hand side value by the number of steps specified by the right hand side value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.LogicAnd">
            <summary>
            Computes the logical and between the left hand side boolean and the right hand side boolean
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.LogicOr">
            <summary>
            Computes the logical or between the left hand side boolean and the right hand side boolean
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.LogicXor">
            <summary>
            Computes the logical xor between the left hand side boolean and the right hand side boolean
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Assignment">
            <summary>
            Assigns the value of the right hand side expression to the left hand side token
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.AddAssign">
            <summary>
            Adds the right hand side to the left hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.SubAssign">
            <summary>
            Subtracts the right hand side from the left hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.DivAssign">
            <summary>
            Divides the left hand side by the right hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.MulAssign">
            <summary>
            Multiplicates the right hand side with the left hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.ModAssign">
            <summary>
            Computes the remainder when dividing the left hand side by the right hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.ShlAssign">
            <summary>
            Shifts left the left hand side by the number of steps indicated by the right hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.ShrAssign">
            <summary>
            Shifts right the left hand side by the number of steps indicated by the right hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.AndAssign">
            <summary>
            Applies a bitwise and between left hand side and right hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.OrAssign">
            <summary>
            Applies a bitwise or between left hand side and right hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.XorAssign">
            <summary>
            Applies a bitwise xor between left hand side and right hand side storing the result in the left hand side
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Data.Operator.Lambda">
            <summary>
            lambda method
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Data.OperatorIndex">
            <summary>
            index of an operator in a token list
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Data.OperatorIndex.#ctor(System.Int32,Pooshit.Scripting.Operations.IOperator)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Data.OperatorIndex"/>
            </summary>
            <param name="index">index where operator is located</param>
            <param name="token">operator token</param>
        </member>
        <member name="P:Pooshit.Scripting.Data.OperatorIndex.Index">
            <summary>
            index where operator is located
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Data.OperatorIndex.Token">
            <summary>
            operator token
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Data.TypeInformation">
            <summary>
            type related information methods
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Data.TypeInformation.GetTypeValue(System.Type)">
            <summary>
            get precision value of a type
            </summary>
            <param name="type">type to analyse</param>
            <returns>precision value used to determine conversion target</returns>
        </member>
        <member name="M:Pooshit.Scripting.Data.TypeInformation.DetermineTargetType(System.Type,System.Type)">
            <summary>
            determines the type to use for operations
            </summary>
            <param name="lhs">left hand type</param>
            <param name="rhs">right hand type</param>
            <returns>type to use for operations</returns>
        </member>
        <member name="M:Pooshit.Scripting.Data.TypeInformation.ConvertOperands(System.Object@,System.Object@)">
            <summary>
            converts operators for an operation
            </summary>
            <param name="lhs">left hand side operand</param>
            <param name="rhs">right hand side operands</param>
        </member>
        <member name="T:Pooshit.Scripting.Data.Variable">
            <summary>
            variable data
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Data.Variable.#ctor(System.String,System.Object)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Data.Variable"/>
            </summary>
            <param name="name">name of variable</param>
            <param name="value">value value (optional)</param>
        </member>
        <member name="P:Pooshit.Scripting.Data.Variable.Name">
            <summary>
            name of variable
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Data.Variable.Value">
            <summary>
            variable value
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Errors.ScriptException">
            <summary>
            exception related to script engine
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Errors.ScriptException.#ctor(System.String)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Errors.ScriptException"/>
            </summary>
            <param name="message">error message</param>
        </member>
        <member name="M:Pooshit.Scripting.Errors.ScriptException.#ctor(System.String,System.Exception)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Errors.ScriptException"/>
            </summary>
            <param name="message">error message</param>
            <param name="innerException">exception which lead to exception</param>
        </member>
        <member name="T:Pooshit.Scripting.Errors.ScriptParserException">
            <summary>
            exception triggered when parser is unable to parse script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Errors.ScriptParserException.#ctor(System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Errors.ScriptParserException"/>
            </summary>
            <param name="message">error message</param>
            <param name="startindex">index where parser error started</param>
            <param name="endindex">index where parser error ended</param>
            <param name="linenumber">line where error was thrown</param>
        </member>
        <member name="M:Pooshit.Scripting.Errors.ScriptParserException.#ctor(System.Int32,System.Int32,System.Int32,System.String,System.Exception)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Errors.ScriptParserException"/>
            </summary>
            <param name="message">error message</param>
            <param name="innerException">exception which triggered this error</param>
            <param name="startindex">index where parser error started</param>
            <param name="endindex">index where parser error ended</param>
            <param name="linenumber">line where error was thrown</param>
        </member>
        <member name="P:Pooshit.Scripting.Errors.ScriptParserException.StartIndex">
            <summary>
            index where parser error started
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Errors.ScriptParserException.EndIndex">
            <summary>
            index where parsing stopped
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Errors.ScriptParserException.Line">
            <summary>
            line where error was thrown
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Errors.ScriptRuntimeException">
            <summary>
            exception triggered when an error was encountered parsing or executing a script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Errors.ScriptRuntimeException.#ctor(System.String,Pooshit.Scripting.Tokens.IScriptToken,System.Exception)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Errors.ScriptRuntimeException"/>
            </summary>
            <param name="message">error message</param>
            <param name="token">token which triggered the error</param>
            <param name="innerException">error which lead to this error</param>
        </member>
        <member name="P:Pooshit.Scripting.Errors.ScriptRuntimeException.Token">
            <summary>
            token which triggered the error
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Errors.ScriptRuntimeException.ContextData">
            <summary>
            context data for error
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.ArrayExtensions.GetHashCode``1(``0[])">
            <summary>
            Gets the hash code for the contents of the array since the default hash code
            for an array is unique even if the contents are the same.
            </summary>
            <remarks>
            See Jon Skeet (C# MVP) response in the StackOverflow thread 
            http://stackoverflow.com/questions/263400/what-is-the-best-algorithm-for-an-overridden-system-object-gethashcode
            </remarks>
            <param name="array">The array to generate a hash code for.</param>
            <returns>The hash code for the values in the array.</returns>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.ArrayExtensions.Equals``1(``0[],``0[])">
            <summary>
            Compares the contents of both arrays to see if they are equal. This depends on 
            typeparameter T having a valid override for Equals().
            </summary>
            <param name="firstArray">The first array to compare.</param>
            <param name="secondArray">The second array to compare.</param>
            <returns>True if firstArray and secondArray have equal contents.</returns>
        </member>
        <member name="T:Pooshit.Scripting.Extensions.DictionaryExtensions">
            <summary>
            extension methods used for dictionary types
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.DictionaryExtensions.ToType(System.Collections.IDictionary,System.Type)">
            <summary>
            converts values of a dictionary to a type
            </summary>
            <param name="dictionary">dictionary containing property values</param>
            <param name="targettype">type to create</param>
            <returns>type created from dictionary</returns>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.DictionaryExtensions.ToType(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type)">
            <summary>
            converts values of a dictionary to a type
            </summary>
            <remarks>
            this is necessary because expandoobjects just implement idictionary&lt;string,object&gt;
            but not idictionary
            </remarks>
            <param name="dictionary">dictionary containing property values</param>
            <param name="targettype">type to create</param>
            <returns>type created from dictionary</returns>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.DictionaryExtensions.FillType(System.Collections.IDictionary,System.Object)">
            <summary>
            fills a type with information stored in a dictionary
            </summary>
            <param name="dictionary"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.DictionaryExtensions.FillType(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object)">
            <summary>
            fills a type with information stored in a dictionary
            </summary>
            <param name="dictionary">dictionary from which to take data</param>
            <param name="value">value to which to transfer data</param>
            <returns></returns>
        </member>
        <member name="T:Pooshit.Scripting.Extensions.OperatorExtensions">
            <summary>
            extensions for comparator tokens
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.OperatorExtensions.GetOrderNumber(Pooshit.Scripting.Data.Operator)">
            <summary>
            get number used to sort operator by priority
            </summary>
            <param name="operator">operator to sort</param>
            <returns>number used in sorting algorithm</returns>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.OperatorExtensions.IsEqual(System.Object,System.Object)">
            <summary>
            determines whether an arbitrary value is equal to another
            </summary>
            <param name="value">value to compare</param>
            <param name="rhs">value to compare this value to for equality</param>
            <returns>true when the two values are considered to be equal, false otherwise</returns>
        </member>
        <member name="T:Pooshit.Scripting.Extensions.ScriptCode">
            <summary>
            helper method for script code
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.ScriptCode.Create(System.String[])">
            <summary>
            creates scriptcode by joining the lines to a single script
            </summary>
            <param name="lines">script code lines</param>
            <returns>script code</returns>
        </member>
        <member name="T:Pooshit.Scripting.Extensions.ScriptExceptionExtensions">
            <summary>
            extensions for script exceptions
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.ScriptExceptionExtensions.CreateStackTrace(Pooshit.Scripting.Errors.ScriptRuntimeException)">
            <summary>
            creates a stack trace based on script code for a <see cref="T:Pooshit.Scripting.Errors.ScriptRuntimeException"/>
            </summary>
            <param name="exception">exception to traverse</param>
            <returns>stack trace</returns>
        </member>
        <member name="T:Pooshit.Scripting.Extensions.TokenExtensions">
            <summary>
            extensions for <see cref="T:Pooshit.Scripting.Tokens.IScriptToken"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.TokenExtensions.Unwrap(System.Collections.Generic.IEnumerable{Pooshit.Scripting.Tokens.Comment})">
            <summary>
            unwraps all comment lines of a series of comments
            </summary>
            <param name="comments">comments to unwrap</param>
            <returns>comment lines contained in comment tokens</returns>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.TokenExtensions.Execute``1(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <summary>
            executes a script and converts the result
            </summary>
            <typeparam name="T">type to convert result to</typeparam>
            <param name="token">token to execute</param>
            <param name="context">context to provide for execution</param>
            <returns>converted token result</returns>
        </member>
        <member name="T:Pooshit.Scripting.Extensions.TypeExtensions">
            <summary>
            extensions for type operations
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.TypeExtensions.DetermineType(Pooshit.Scripting.Parser.ITypeProvider,System.String)">
            <summary>
            determines the specified type from a string
            </summary>
            <param name="provider">provider for script named types</param>
            <param name="token">token from which type should be determined</param>
            <param name="typename">name of type</param>
            <returns>Type determined from string</returns>
        </member>
        <member name="M:Pooshit.Scripting.Extensions.TypeExtensions.IsNullable(System.Type)">
            <summary>
            determines whether the specified type is a nullable type
            </summary>
            <param name="type">type to check</param>
            <returns></returns>
        </member>
        <member name="T:Pooshit.Scripting.Extensions.ValueExtensions">
            <summary>
            extensions for values
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Extern.ConversionKey">
            <summary>
            key used for specific conversion
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extern.ConversionKey.#ctor(System.Type,System.Type)">
            <summary>
            ctor
            </summary>
            <param name="sourcetype"></param>
            <param name="targettype"></param>
        </member>
        <member name="P:Pooshit.Scripting.Extern.ConversionKey.SourceType">
            <summary>
            source type from which to convert
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Extern.ConversionKey.TargetType">
            <summary>
            target type to which to convert
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Extern.Converter">
            <summary>
            converter used to convert data types
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extern.Converter.#cctor">
            <summary>
            cctor
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Extern.Converter.RegisterConverter(Pooshit.Scripting.Extern.ConversionKey,System.Func{System.Object,System.Object})">
            <summary>
            registers a specific converter to be used for a specific conversion
            </summary>
            <param name="key"></param>
            <param name="converter"></param>
        </member>
        <member name="M:Pooshit.Scripting.Extern.Converter.Convert(System.Object,System.Type,System.Boolean)">
            <summary>
            converts the value to a specific target type
            </summary>
            <param name="value"></param>
            <param name="targettype"></param>
            <param name="allownullonvaluetypes"> </param>
            <returns></returns>
        </member>
        <member name="M:Pooshit.Scripting.Extern.Converter.Convert``1(System.Object,System.Boolean)">
            <summary>
            converts the value to the specified target type
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="allownullonvaluetypes"> </param>
            <returns></returns>
        </member>
        <member name="T:Pooshit.Scripting.Formatters.IScriptFormatter">
            <summary>
            formats scripts for text editors
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.IScriptFormatter.FormatScript(Pooshit.Scripting.IScript)">
            <summary>
            converts a script into a readable string format
            </summary>
            <param name="script">script to format</param>
            <returns>formatted script string</returns>
        </member>
        <member name="T:Pooshit.Scripting.Formatters.ScriptFormatter">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Formatters.ScriptFormatter.#ctor(Pooshit.Scripting.Formatters.Tokens.IFormatterCollection)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Formatters.ScriptFormatter"/>
            </summary>
            <param name="formatters">formatters to use when formatting tokens (optional)</param>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.ScriptFormatter.FormatScript(Pooshit.Scripting.IScript)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.ArithmeticFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.ArithmeticBlock"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.ArithmeticFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.ArrayFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.ScriptArray"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.ArrayFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.BinaryTokenFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Operations.IBinaryToken"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.BinaryTokenFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.CastFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.ImpliciteTypeCast"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.CastFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.CommentFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.Comment"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.CommentFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.DefaultFormatter">
            <summary>
            formatter to use if no formatter applies
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Formatters.Tokens.DefaultFormatter.Instance">
            <summary>
            static instance of a default formatter
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.DefaultFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.DefaultFormatterCollection">
            <summary>
            formatter collection with default entries
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.DefaultFormatterCollection.#ctor">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Formatters.Tokens.DefaultFormatterCollection"/>
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.DictionaryFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.DictionaryToken"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.DictionaryFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.FormatterCollection">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Formatters.Tokens.FormatterCollection.Item(Pooshit.Scripting.Tokens.IScriptToken)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.FormatterCollection.AddFormatter(System.Type,Pooshit.Scripting.Formatters.Tokens.ITokenFormatter)">
            <summary>
            adds a formatter for a specific token type
            </summary>
            <param name="tokentype">token type for which to set formatter</param>
            <param name="formatter">formatter to use for token</param>
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.IfFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Control.If"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.IfFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.IFormatterCollection">
            <summary>
            collection of available formatters
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Formatters.Tokens.IFormatterCollection.Item(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            get a formatter for the specified token
            </summary>
            <param name="tokentype">type of token to get formatter for</param>
            <returns>formatter to use to format token</returns>
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.IndexerFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.ScriptIndexer"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.IndexerFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.InterpolationFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.StringInterpolation"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.InterpolationFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.ITokenFormatter">
            <summary>
            formats a token for a <see cref="T:Pooshit.Scripting.Formatters.IScriptFormatter"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.ITokenFormatter.FormatToken(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32,System.Boolean)">
            <summary>
            formats a token to a result text
            </summary>
            <param name="token">token to format</param>
            <param name="resulttext">text where formatted string is stored</param>
            <param name="formatters">available formatters</param>
            <param name="depth">block depth in hierarchy</param>
            <param name="mustindent">determines whether depth is just an indicator or must be applied</param>
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.MemberFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.ScriptMember"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.MemberFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.MethodFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.ScriptMethod"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.MethodFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.NewFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.NewInstance"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.NewFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.NewLineFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.NewLine"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.NewLineFormatter.FormatToken(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.StatementBlockFormatter">
            <summary>
            formats a statement body for a script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.StatementBlockFormatter.FormatToken(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.SwitchFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Control.Switch"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.SwitchFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.ThrowFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Control.Throw"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.ThrowFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.TokenFormatter">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.TokenFormatter.FormatBody(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <summary>
            formats a body for a control token
            </summary>
            <param name="token">body token</param>
            <param name="resulttext">formatted result target</param>
            <param name="formatters">collection of token formatters</param>
            <param name="depth">indentation depth (should be depth of control token)</param>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.TokenFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <summary>
            formats a token
            </summary>
            <param name="token">token to format</param>
            <param name="resulttext">text to append formatted token to</param>
            <param name="formatters">formatter collection to retrieve token formatters from</param>
            <param name="depth">current indentation depth</param>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.TokenFormatter.AppendIntendation(System.Text.StringBuilder,System.Int32)">
            <summary>
            creates an intendation for a specified depth
            </summary>
            <param name="resulttext">text to append intendation for</param>
            <param name="depth">indentation depth</param>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.TokenFormatter.FormatToken(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.TryFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Control.Try"/> / Catch blocks
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.TryFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.UnaryTokenFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Operations.IUnaryToken"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.UnaryTokenFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.ValueFormatter">
            <summary>
            formats <see cref="T:Pooshit.Scripting.Tokens.ScriptValue"/>s
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.ValueFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Formatters.Tokens.VariableFormatter">
            <summary>
            formatter for a <see cref="T:Pooshit.Scripting.Tokens.ScriptVariable"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Formatters.Tokens.VariableFormatter.Format(Pooshit.Scripting.Tokens.IScriptToken,System.Text.StringBuilder,Pooshit.Scripting.Formatters.Tokens.IFormatterCollection,System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Hosts.TaskHost">
            <summary>
            provides methods for tasks
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Hosts.TaskHost.Run(Pooshit.Scripting.Providers.LambdaMethod)">
            <summary>
            starts a new task from a lambda method
            </summary>
            <param name="method">method to run as task</param>
            <returns>task object containing running method</returns>
        </member>
        <member name="M:Pooshit.Scripting.Hosts.TaskHost.FromResult(System.Object)">
            <summary>
            creates a completed task object form a result value
            </summary>
            <param name="result">value to wrap as task result</param>
            <returns>task object</returns>
        </member>
        <member name="M:Pooshit.Scripting.Hosts.TaskHost.FromResult``1(``0)">
            <summary>
            creates a completed task object form a result value
            </summary>
            <param name="result">value to wrap as task result</param>
            <returns>task object</returns>
        </member>
        <member name="M:Pooshit.Scripting.Hosts.TaskHost.WaitAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task})">
            <summary>
            waits for all tasks to complete
            </summary>
            <param name="tasks">tasks to wait for</param>
        </member>
        <member name="T:Pooshit.Scripting.Hosts.TypeHost">
            <summary>
            provides methods to interact with types in scripts
            </summary>
            <remarks>
            handle with caution since type interaction can easily break security measures
            </remarks>
        </member>
        <member name="M:Pooshit.Scripting.Hosts.TypeHost.#ctor(Pooshit.Scripting.Parser.ITypeProvider)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Hosts.TypeHost"/>
            </summary>
            <param name="typeProvider">type provider containing script type information</param>
        </member>
        <member name="P:Pooshit.Scripting.Hosts.TypeHost.TypeProvider">
            <summary>
            type provider to use
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Hosts.TypeHost.Create(System.String,System.Collections.Generic.Dictionary{System.Object,System.Object})">
            <summary>
            creates a new type instance from a dictionary
            </summary>
            <param name="typename">name of type to create</param>
            <param name="dictionary">dictionary values containing values for instance properties</param>
            <returns>created type</returns>
        </member>
        <member name="T:Pooshit.Scripting.IScript">
            <summary>
            interface for a script
            </summary>
            <remarks>does the same as <see cref="T:Pooshit.Scripting.Tokens.IScriptToken"/> but has a more clear name</remarks>
        </member>
        <member name="M:Pooshit.Scripting.IScript.Execute(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            executes the script and returns the result
            </summary>
            <returns>script result</returns>
        </member>
        <member name="M:Pooshit.Scripting.IScript.Execute(Pooshit.Scripting.Parser.IVariableProvider)">
            <summary>
            executes the script and returns the result
            </summary>
            <returns>script result</returns>
        </member>
        <member name="M:Pooshit.Scripting.IScript.Execute``1(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            executes the script and returns a typed result
            </summary>
            <remarks>
            this just executes <see cref="M:Pooshit.Scripting.IScript.Execute(System.Collections.Generic.IDictionary{System.String,System.Object})"/> and tries to convert the result
            </remarks>
            <typeparam name="T">type of result to return</typeparam>
            <returns>result of script execution</returns>
        </member>
        <member name="M:Pooshit.Scripting.IScript.Execute``1(Pooshit.Scripting.Parser.IVariableProvider)">
            <summary>
            executes the script and returns a typed result
            </summary>
            <remarks>
            this just executes <see cref="M:Pooshit.Scripting.IScript.Execute(System.Collections.Generic.IDictionary{System.String,System.Object})"/> and tries to convert the result
            </remarks>
            <typeparam name="T">type of result to return</typeparam>
            <returns>result of script execution</returns>
        </member>
        <member name="M:Pooshit.Scripting.IScript.ExecuteAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <summary>
            executes the script and returns the result
            </summary>
            <returns>script result</returns>
        </member>
        <member name="M:Pooshit.Scripting.IScript.ExecuteAsync(Pooshit.Scripting.Parser.IVariableProvider,System.Threading.CancellationToken)">
            <summary>
            executes the script and returns the result
            </summary>
            <returns>script result</returns>
        </member>
        <member name="M:Pooshit.Scripting.IScript.ExecuteAsync``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <summary>
            executes the script and returns a typed result
            </summary>
            <remarks>
            this just executes <see cref="M:Pooshit.Scripting.IScript.Execute(System.Collections.Generic.IDictionary{System.String,System.Object})"/> and tries to convert the result
            </remarks>
            <typeparam name="T">type of result to return</typeparam>
            <returns>result of script execution</returns>
        </member>
        <member name="M:Pooshit.Scripting.IScript.ExecuteAsync``1(Pooshit.Scripting.Parser.IVariableProvider,System.Threading.CancellationToken)">
            <summary>
            executes the script and returns a typed result
            </summary>
            <remarks>
            this just executes <see cref="M:Pooshit.Scripting.IScript.Execute(System.Collections.Generic.IDictionary{System.String,System.Object})"/> and tries to convert the result
            </remarks>
            <typeparam name="T">type of result to return</typeparam>
            <returns>result of script execution</returns>
        </member>
        <member name="P:Pooshit.Scripting.IScript.Body">
            <summary>
            script body
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Operations.AssignableToken">
            <summary>
            base implementation which handles errors
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.AssignableToken.Assign(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.AssignableToken.AssignToken(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <summary>
            executes assignment
            </summary>
            <param name="token">token with value to assign</param>
            <param name="context">script execution context</param>
            <returns>result of assignment</returns>
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.AddAssign">
            <summary>
            adds a value to the result of a token and assigns it at the same time
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.AddAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.AddAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.AddAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.AddAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.AndAssign">
            <summary>
            computes bitwise and of lhs and rhs and assigns the result to lhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.AndAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.AndAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.AndAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.AndAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.Assignment">
            <summary>
            assignment in a script
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.Assignment.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.Assignment.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.Assignment.AssignToken(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.Assignment.Lhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.Assignment.Rhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.Assignment.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.Assignment.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.DivAssign">
            <summary>
            divides a value by the result of a token and assigns it to the same token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.DivAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.DivAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.DivAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.DivAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.ModAssign">
            <summary>
            computes modulus of a value with the result of a token and assigns it to the same token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.ModAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.ModAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.ModAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.ModAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.MulAssign">
            <summary>
            multiplies a value from the result of a token and assigns it to the same token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.MulAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.MulAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.MulAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.MulAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.OperatorAssign">
            <summary>
            computes the result of a binary operation and assigns the result to lhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.OperatorAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <summary>
            computes the result of the operation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.OperatorAssign.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.OperatorAssign.Lhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.OperatorAssign.Rhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.OperatorAssign.Operator">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.OrAssign">
            <summary>
            computes bitwise and of lhs and rhs and assigns the result to lhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.OrAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.OrAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.OrAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.OrAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.ShlAssign">
            <summary>
            shifts bits of a value to the left by the result of a token and assigns it to the same token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.ShlAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.ShlAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.ShlAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.ShlAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.ShrAssign">
            <summary>
            shifts bits of a value to the right by the result of a token and assigns it to the same token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.ShrAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.ShrAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.ShrAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.ShrAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.SubAssign">
            <summary>
            subtracts a value from the result of a token and assigns it to the same token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.SubAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.SubAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.SubAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.SubAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Assign.XorAssign">
            <summary>
            computes bitwise and of lhs and rhs and assigns the result to lhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.XorAssign.Compute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.XorAssign.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Assign.XorAssign.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Assign.XorAssign.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.Comparator">
            <summary>
            operator used to compare two values resulting in a boolean
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Comparator.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <summary>
            compares lhs and rhs and returns value of comparision
            </summary>
            <returns>comparision value</returns>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Comparator.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Comparator.Lhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Comparator.Rhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Comparator.Operator">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.Equal">
            <summary>
            compares two values for equality
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Equal.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Equal.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Equal.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Equal.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.Greater">
            <summary>
            compares whether lhs is less than rhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Greater.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Greater.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Greater.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Greater.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.GreaterOrEqual">
            <summary>
            compares whether lhs is less than rhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.GreaterOrEqual.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.GreaterOrEqual.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.GreaterOrEqual.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.GreaterOrEqual.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.Less">
            <summary>
            compares whether lhs is less than rhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Less.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Less.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Less.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Less.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.LessOrEqual">
            <summary>
            compares whether lhs is less than rhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.LessOrEqual.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.LessOrEqual.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.LessOrEqual.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.LessOrEqual.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.Matches">
            <summary>
            determines whether a string matches a regex
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Matches.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Matches.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.Matches.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.Matches.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.MatchesNot">
            <summary>
            determines whether a string matches a regex
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.MatchesNot.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.MatchesNot.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.MatchesNot.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.MatchesNot.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Comparision.NotEqual">
            <summary>
            compares two values whether they are not equal
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.NotEqual.Compare(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.NotEqual.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Comparision.NotEqual.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Comparision.NotEqual.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.IAssignableToken">
            <summary>
            token to which a value can be assigned
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.IAssignableToken.Assign(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <summary>
            assigns a value to this token
            </summary>
            <param name="token">token resulting in value to assign to this token</param>
            <param name="context">script execution context</param>
            <returns>resulting value after assignment</returns>
        </member>
        <member name="T:Pooshit.Scripting.Operations.IBinaryToken">
            <summary>
            token applying an operation to two operands
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.IBinaryToken.Lhs">
            <summary>
            left hand side operand
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.IBinaryToken.Rhs">
            <summary>
            right hand side operand
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Operations.IOperator">
            <summary>
            scripttoken which operates on other tokens
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.IOperator.Operator">
            <summary>
            type of operator
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Operations.IUnaryToken">
            <summary>
            token applying an operation to a single operand
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.IUnaryToken.IsPostToken">
            <summary>
            determines whether the operand is ahead of this token or behind it
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.IUnaryToken.Operand">
            <summary>
            operand for operation
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Operations.Logic.LogicAnd">
            <summary>
            computes logical AND of lhs and rhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicAnd.Operate(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicAnd.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicAnd.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicAnd.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Logic.LogicOperation">
            <summary>
            logic operation on boolean operands
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicOperation.Operate(Pooshit.Scripting.ScriptContext)">
            <summary>
            executes the logic operation
            </summary>
            <returns>result of logic operation</returns>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicOperation.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicOperation.Lhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicOperation.Rhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicOperation.Operator">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Logic.LogicOr">
            <summary>
            computes logical OR of lhs and rhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicOr.Operate(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicOr.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicOr.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicOr.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Logic.LogicXor">
            <summary>
            computes logical XOR of lhs and rhs
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicXor.Operate(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicXor.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Logic.LogicXor.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Logic.LogicXor.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.MethodOperations">
            <summary>
            operations used when calling methods dynamically
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.MethodOperations.MatchesParameterCount(System.Reflection.MethodBase,System.Int32,System.Boolean)">
            <summary>
            determines whether a method could be called using the provided parameters 
            </summary>
            <remarks>
            this does not determine whether the parameter types actually matches, it only determines whether the parameter count matches
            </remarks>
            <param name="method">method to check</param>
            <param name="parametercount">number of parameters</param>
            <param name="isextension">determines whether the method is an extension method</param>
            <returns>true if method count matches, false otherwise</returns>
        </member>
        <member name="M:Pooshit.Scripting.Operations.MethodOperations.CallConstructor(System.Reflection.ConstructorInfo,Pooshit.Scripting.Tokens.IScriptToken[],Pooshit.Scripting.ScriptContext)">
            <summary>
            calls a constructor using the specified parameters
            </summary>
            <param name="constructor">constructor to call</param>
            <param name="parameters">parameters for constructor</param>
            <param name="context">execution context</param>
            <returns>constructed object</returns>
        </member>
        <member name="T:Pooshit.Scripting.Operations.Unary.Complement">
            <summary>
            computes the bit-complement of the result of a token
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Complement.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Complement.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Complement.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Complement.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Unary.Decrement">
            <summary>
            increments the value of a token by 1
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Decrement.#ctor(System.Boolean)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Operations.Unary.Decrement"/>
            </summary>
            <param name="post">determines whether this is a post-increment or a pre-increment</param>
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Decrement.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Decrement.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Decrement.IsPostToken">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Decrement.Operand">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Decrement.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Decrement.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Unary.Increment">
            <summary>
            increments the value of a token by 1
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Increment.#ctor(System.Boolean)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Operations.Unary.Increment"/>
            </summary>
            <param name="post">determines whether this is a post-increment or a pre-increment</param>
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Increment.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Increment.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Increment.IsPostToken">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Increment.Operand">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Increment.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Increment.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Unary.Negate">
            <summary>
            negates the value of a token
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Negate.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Negate.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Negate.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Negate.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Unary.Not">
            <summary>
            logical negation of boolean values
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Not.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Not.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.Not.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Unary.Not.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Unary.UnaryOperator">
            <summary>
            operator which acts on a single operand which is usually following the operator
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.UnaryOperator.IsPostToken">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.UnaryOperator.Operand">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Unary.UnaryOperator.Operator">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.Addition">
            <summary>
            adds two values or concatenates two strings
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Addition.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Addition.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Addition.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Addition.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.BitwiseAnd">
            <summary>
            executes a bitwise and on two integer values
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.BitwiseAnd.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.BitwiseAnd.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.BitwiseAnd.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.BitwiseAnd.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.BitwiseOr">
            <summary>
            executes a bitwise OR on two integer values
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.BitwiseOr.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.BitwiseOr.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.BitwiseOr.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.BitwiseOr.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.BitwiseXor">
            <summary>
            executes a bitwise XOR on two integer values
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.BitwiseXor.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.BitwiseXor.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.BitwiseXor.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.BitwiseXor.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.Division">
            <summary>
            divides LHS by RHS
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Division.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Division.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Division.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Division.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.Modulo">
            <summary>
            computes the modulus when dividing LHS by RHS
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Modulo.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Modulo.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Modulo.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Modulo.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.Multiplication">
            <summary>
            multiplies two values
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Multiplication.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Multiplication.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Multiplication.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Multiplication.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.RolLeft">
            <summary>
            rolls bits of lhs to the left by rhs steps
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.RolLeft.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.RolLeft.Operator">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.RolLeft.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.RolRight">
            <summary>
            rolls bits of lhs to the left by rhs steps
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.RolRight.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.RolRight.Operator">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.RolRight.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.ShiftLeft">
            <summary>
            shifts the bits of LHS by RHS to the left
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.ShiftLeft.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.ShiftLeft.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.ShiftLeft.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.ShiftLeft.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.ShiftRight">
            <summary>
            shifts the bits of LHS by RHS to the right
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.ShiftRight.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.ShiftRight.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.ShiftRight.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.ShiftRight.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.Subtraction">
            <summary>
            subtracts a RHS from LHS
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Subtraction.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Subtraction.Operator">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.Subtraction.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.Subtraction.Literal">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Operations.Values.ValueOperation">
            <summary>
            arithmetic operation to apply to two operands
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.ValueOperation.Operate(System.Object,System.Object,Pooshit.Scripting.ScriptContext)">
            <summary>
            executes the value operation
            </summary>
            <returns>result of operation</returns>
        </member>
        <member name="M:Pooshit.Scripting.Operations.Values.ValueOperation.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.ValueOperation.Operator">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.ValueOperation.Lhs">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Operations.Values.ValueOperation.Rhs">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Parser.ExtensionProvider">
            <summary>
            plain implementation of <see cref="T:Pooshit.Scripting.Parser.IExtensionProvider"/> providing hosts and extension methods
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ExtensionProvider.Item(System.Type)">
            <summary>
            indexer for extension methods
            </summary>
            <param name="host">host type for which to get extension methods</param>
            <returns>available extension methods</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ExtensionProvider.AddExtensionMethod(System.Type,System.Reflection.MethodInfo)">
            <summary>
            adds an extension method to the script pool
            </summary>
            <param name="hosttype">type of host for which to add extension</param>
            <param name="method">method to add</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ExtensionProvider.AddExtensions``1">
            <summary>
            adds methods of an extension type
            </summary>
            <typeparam name="T">type of which to add extension methods</typeparam>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ExtensionProvider.AddExtensions(System.Type)">
            <summary>
            adds methods of an extension type
            </summary>
            <param name="extensiontype">type of which to add extension methods</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ExtensionProvider.GetExtensions(System.Type)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Parser.Extract.ITokenExtractor">
            <summary>
            extracts single tokens from scripts
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Extract.ITokenExtractor.ExtractToken(System.String,System.Int32,System.Boolean,System.Func{Pooshit.Scripting.Tokens.IScriptToken,System.Boolean})">
            <summary>
            extracts token which is stored at the specified position
            </summary>
            <param name="data">script data to analyse</param>
            <param name="position">position at which to extract token</param>
            <param name="fulltoken">determines whether to extract the full token or just the token literal up until the specified position</param>
            <param name="filter">filter for tokens to match to get considered for extraction(optional)</param>
            <returns>extracted token</returns>
        </member>
        <member name="T:Pooshit.Scripting.Parser.Extract.TokenExtractionVisitor">
            <summary>
            visits a script to extract a token at a specific position
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Extract.TokenExtractionVisitor.#ctor(System.Int32,System.Func{Pooshit.Scripting.Tokens.IScriptToken,System.Boolean})">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.Extract.TokenExtractor"/>
            </summary>
            <param name="position">position at which to extract token</param>
            <param name="filter">filter for tokens to match</param>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Extract.TokenExtractionVisitor.Token">
            <summary>
            extracted token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Extract.TokenExtractionVisitor.VisitToken(Pooshit.Scripting.Tokens.IScriptToken)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Parser.Extract.TokenExtractor">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.Extract.TokenExtractor.#ctor(Pooshit.Scripting.Parser.IScriptParser)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.Extract.TokenExtractor"/>
            </summary>
            <param name="parser">parser to use to extract token</param>
        </member>
        <member name="T:Pooshit.Scripting.Parser.IExtensionProvider">
            <summary>
            interface for a pool of script hosts
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IExtensionProvider.GetExtensions(System.Type)">
            <summary>
            get extension methods available for type
            </summary>
            <param name="host">type of host for which to get extension methods</param>
            <returns>methods available as extension methods</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IExtensionProvider.AddExtensions(System.Type)">
            <summary>
            adds methods of an extension type
            </summary>
            <param name="extensiontype">type of which to add extension methods</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IExtensionProvider.AddExtensions``1">
            <summary>
            adds methods of an extension type
            </summary>
            <typeparam name="T">type of which to add extension methods</typeparam>
        </member>
        <member name="T:Pooshit.Scripting.Parser.IScriptParser">
            <summary>
            interface for a parser of script code
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.IScriptParser.Extensions">
            <summary>
            access to extensions available to script environment
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.IScriptParser.Types">
            <summary>
            access to types which can be created using 'new' keyword
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.IScriptParser.ImportProvider">
            <summary>
            resolver which is used by 'import' statement to import methods
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IScriptParser.Parse(System.String)">
            <summary>
            parses a script for execution
            </summary>
            <param name="data">data to parse</param>
            <returns>script which can get executed</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IScriptParser.ParseAsync(System.String)">
            <summary>
            parses a script for execution in a task
            </summary>
            <param name="data">script code to parse</param>
            <returns>script parsed from code</returns>
        </member>
        <member name="T:Pooshit.Scripting.Parser.ITypeInstanceProvider">
            <summary>
            interface for a provider of type-instances
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ITypeInstanceProvider.ProvidedType">
            <summary>
            type which is provided
            </summary>
            <remarks>
            this type actually does not need to match up with the provided type and is just used as info
            it would be nice however to be honest here
            </remarks>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ITypeInstanceProvider.Create(Pooshit.Scripting.Tokens.IScriptToken[],Pooshit.Scripting.ScriptContext)">
            <summary>
            creates an instance using the specified parameters
            </summary>
            <param name="parameters">parameters to use to create the instance</param>
            <param name="context">script execution context</param>
            <returns>created instance</returns>
        </member>
        <member name="T:Pooshit.Scripting.Parser.ITypeProvider">
            <summary>
            provides types which can be created in script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ITypeProvider.GetType(System.String)">
            <summary>
            get type instance provider which is registered under the specified name
            </summary>
            <param name="name">name of type to get</param>
            <returns>instance provider for requested type</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ITypeProvider.AddType(System.String,Pooshit.Scripting.Parser.ITypeInstanceProvider)">
            <summary>
            adds an instance provider for a type
            </summary>
            <param name="name">name of type to add</param>
            <param name="provider">instance provider</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ITypeProvider.AddType(System.Type,System.String)">
            <summary>
            adds an instance provider for a type
            </summary>
            <param name="name">name of type to add</param>
            <param name="type">type to add</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ITypeProvider.AddType``1(System.String)">
            <summary>
            adds a type using a type provider calling existing constructors
            </summary>
            <typeparam name="T">type to create</typeparam>
            <param name="name">name to use to create type</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ITypeProvider.RemoveType(System.String)">
            <summary>
            removes the specified type instance provider
            </summary>
            <param name="name">name of type to remove</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ITypeProvider.HasType(System.String)">
            <summary>
            determines whether the type provider contains a specific type
            </summary>
            <param name="name">name of type</param>
            <returns>true if type information exists, false otherwise</returns>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ITypeProvider.ProvidedTypes">
            <summary>
            types provdided
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Parser.IVariableProvider">
            <summary>
            provides named variables to script
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.IVariableProvider.Item(System.String)">
            <summary>
            indexer to variable provider
            </summary>
            <param name="name">name of variable</param>
            <returns>value of variable</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IVariableProvider.GetVariable(System.String)">
            <summary>
            get value of a variable
            </summary>
            <param name="name">name of variable</param>
            <returns>variable value</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IVariableProvider.ContainsVariable(System.String)">
            <summary>
            determines whether the context contains a variable with the specified name
            </summary>
            <param name="name">name of variable to check for</param>
            <returns>true if variable is in this context, false otherwise</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IVariableProvider.ContainsVariableInHierarchy(System.String)">
            <summary>
            determines whether the context contains a variable with the specified name in any of the providers in hierarchy
            </summary>
            <param name="name">name of variable to check for</param>
            <returns>true if variable is in this context, false otherwise</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.IVariableProvider.GetProvider(System.String)">
            <summary>
            get provider in chain which contains a variable with the specified name
            </summary>
            <param name="variable">name of variable to check for</param>
            <returns>next provider which contains this variable, null if the variable is not found</returns>
        </member>
        <member name="P:Pooshit.Scripting.Parser.IVariableProvider.Variables">
            <summary>
            variables available to this provider
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Parser.Operators.OperatorNode">
            <summary>
            node in an operator tree
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Operators.OperatorNode.#ctor(System.Char)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.Operators.OperatorNode"/>
            </summary>
            <param name="character">character of node</param>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Operators.OperatorNode.Item(System.Char)">
            <summary>
            access to children of node
            </summary>
            <param name="character">character identifying the child</param>
            <returns>node mapping to the specified character</returns>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Operators.OperatorNode.Character">
            <summary>
            character defining the leaf
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Operators.OperatorNode.Operator">
            <summary>
            operator mapped to the node
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Operators.OperatorNode.HasChildren">
            <summary>
            determines whether the operator node has children
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Operators.OperatorNode.Clear">
            <summary>
            clears all children of this node
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Operators.OperatorNode.GetChildOrDefault(System.Char)">
            <summary>
            get child if it exists in node or null if no child is found for character
            </summary>
            <param name="character">character leading to the node</param>
            <returns>node if any is found or null</returns>
        </member>
        <member name="T:Pooshit.Scripting.Parser.Operators.OperatorTree">
            <summary>
            tree containing operator information
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Operators.OperatorTree.Root">
            <summary>
            tree trunk
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Operators.OperatorTree.Clear">
            <summary>
            clears all entries of the tree
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Operators.OperatorTree.Add(System.String,Pooshit.Scripting.Data.Operator)">
            <summary>
            adds an operator to the tree
            </summary>
            <param name="data">data identifying the operator</param>
            <param name="op">operator type</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Operators.OperatorTree.Get(System.String)">
            <summary>
            get the operator node matching to the data
            </summary>
            <param name="data">data making up the operator</param>
            <returns>node matching the operator data</returns>
        </member>
        <member name="T:Pooshit.Scripting.Parser.ParserOptions">
            <summary>
            options for parser
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ParserOptions.IncludeNonExecutableTokens">
            <summary>
            whether to include tokens which have to effect in script
            </summary>
            <remarks>
            e.g. comments
            </remarks>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ParserOptions.Variables">
            <summary>
            variables to use when parsing script
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Parser.Resolvers.IMethodResolver">
            <summary>
            resolves method calls for <see cref="T:Pooshit.Scripting.Tokens.ScriptMethod"/> tokens
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.IMethodResolver.Resolve(System.Object,System.String,System.Object[],Pooshit.Scripting.Tokens.ReferenceParameter[],System.Type[])">
            <summary>
            resolves the method to call
            </summary>
            <param name="host">host on which to call a method</param>
            <param name="methodname">name of method to call</param>
            <param name="parameters">method parameters</param>
            <param name="referenceparameters">reference parameter information</param>
            <param name="genericparameters">parameters for generic method templates</param>
            <returns>resolved method to call</returns>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.IMethodResolver.ResolveConstructor(System.Type,System.Object[])">
            <summary>
            resolves a constructor to call
            </summary>
            <param name="type">type of which to call constructor</param>
            <param name="parameters">parameters for constructor call</param>
            <returns>constructor to be called</returns>
        </member>
        <member name="T:Pooshit.Scripting.Parser.Resolvers.IResolvedMethod">
            <summary>
            method to be called
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.IResolvedMethod.Call(Pooshit.Scripting.Tokens.IScriptToken,System.Object,System.Object[],Pooshit.Scripting.ScriptContext)">
            <summary>
            calls a method
            </summary>
            <param name="methodcall">original method token</param>
            <param name="host">host for which to call method</param>
            <param name="parameters">parameters for method call</param>
            <param name="context">script context</param>
            <returns>return value of method</returns>
        </member>
        <member name="T:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey">
            <summary>
            key for a method call
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey.#ctor(System.Type,System.String,System.Type[],Pooshit.Scripting.Tokens.ReferenceParameter[],System.Type[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey"/>
            </summary>
            <param name="hostType">type of host to call method on</param>
            <param name="methodName">method to call</param>
            <param name="parameterTypes">parameter value types</param>
            <param name="referenceInformation">information about reference parameters (optional)</param>
            <param name="genericarguments">arguments for generic method templates</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey.#ctor(System.Type,System.Type[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey"/>
            </summary>
            <param name="hostType">type of host to call method on</param>
            <param name="parameterTypes">parameter value types</param>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey.HostType">
            <summary>
            type of host to call method on
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey.MethodName">
            <summary>
            method to call
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey.ParameterTypes">
            <summary>
            parameter value types
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey.GenericArguments">
            <summary>
            arguments for generic method templates
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.MethodCacheKey.ReferenceInformation">
            <summary>
            information about reference parameters
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Parser.Resolvers.MethodResolver">
            <summary>
            default method provider
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.MethodResolver.#ctor(Pooshit.Scripting.Parser.IExtensionProvider)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.Resolvers.MethodResolver"/>
            </summary>
            <param name="extensions">access to extension methods</param>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.MethodResolver.EnableCaching">
            <summary>
            determines whether to cache resolved methods for later calls
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.MethodResolver.Resolve(System.Object,System.String,System.Object[],Pooshit.Scripting.Tokens.ReferenceParameter[],System.Type[])">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.MethodResolver.ResolveConstructor(System.Type,System.Object[])">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Parser.Resolvers.ResolvedMethod">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.ResolvedMethod.#ctor(System.Reflection.MethodInfo,Pooshit.Scripting.Tokens.ReferenceParameter[],System.Boolean)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.Resolvers.ResolvedMethod"/>
            </summary>
            <param name="method">method to call</param>
            <param name="referenceParameters">reference parameter information</param>
            <param name="isExtension">determines whether invocation is an extension method</param>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.ResolvedMethod.Method">
            <summary>
            method to call
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.ResolvedMethod.IsExtension">
            <summary>
            determines whether invocation is an extension method
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.Resolvers.ResolvedMethod.ReferenceParameters">
            <summary>
            reference parameter information
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.Resolvers.ResolvedMethod.Call(Pooshit.Scripting.Tokens.IScriptToken,System.Object,System.Object[],Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Parser.ScriptParser">
            <summary>
            parses scripts from string data
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ScriptParser.#ctor">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.ScriptParser"/>
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.TypeInstanceProvidersEnabled">
            <summary>
            enables usage of new in scripts
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.ControlTokensEnabled">
            <summary>
            enables usage of control tokens in scripts (if,for,while)
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.TypeCastsEnabled">
            <summary>
            enables type casts
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.ImportsEnabled">
            <summary>
            enables external method imports
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.MetatokensEnabled">
            <summary>
            determines whether meta tokens are included in parsed script
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.Extensions">
            <summary>
            access to extensions available to script environment
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.Types">
            <summary>
            access to types which can be created using 'new' keyword
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.ImportProvider">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.MethodCallResolver">
            <summary>
            resolves methods to call for <see cref="T:Pooshit.Scripting.Tokens.ScriptMethod"/>s
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Parser.ScriptParser.OperatorTree">
            <summary>
            tree containing all supported operators
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.ScriptParser.Parse(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.ScriptParser.ParseAsync(System.String)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Parser.TokenType">
            <summary>
            token types known to parser
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Literal">
            <summary>
            string type
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Number">
            <summary>
            number
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Variable">
            <summary>
            variable value
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Control">
            <summary>
            control specifier
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Type">
            <summary>
            registered type
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Method">
            <summary>
            method call
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Property">
            <summary>
            property
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Operator">
            <summary>
            operator
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Comment">
            <summary>
            code comment
            </summary>
        </member>
        <member name="F:Pooshit.Scripting.Parser.TokenType.Parameter">
            <summary>
            variable which has to get provided to the script
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Parser.TypeProvider">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.TypeProvider.#ctor(Pooshit.Scripting.Parser.Resolvers.IMethodResolver)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.TypeProvider"/>
            </summary>
            <param name="resolver">provided to typeinstance provider</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.TypeProvider.GetType(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.TypeProvider.AddType(System.String,Pooshit.Scripting.Parser.ITypeInstanceProvider)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.TypeProvider.AddType(System.Type,System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.TypeProvider.AddType``1(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.TypeProvider.RemoveType(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.TypeProvider.HasType(System.String)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Parser.TypeProvider.ProvidedTypes">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Parser.VariableProvider">
            <summary>
            basic implementation of a variable provider used if no custom provider is specified
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.#ctor(Pooshit.Scripting.Data.Variable[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.VariableProvider"/>
            </summary>
            <param name="variables">variables to provide</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.#ctor(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.VariableProvider"/>
            </summary>
            <param name="variables">variables to provide</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.#ctor(Pooshit.Scripting.Parser.IVariableProvider,Pooshit.Scripting.Data.Variable[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.VariableProvider"/>
            </summary>
            <param name="parentprovider">parent variable scope</param>
            <param name="variables">variables to provide</param>
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.#ctor(Pooshit.Scripting.Parser.IVariableProvider,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.VariableProvider"/>
            </summary>
            <param name="parentprovider">parent variable scope</param>
            <param name="variables">variables to provide</param>
        </member>
        <member name="P:Pooshit.Scripting.Parser.VariableProvider.Item(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.ReplaceVariable(System.String,System.Object)">
            <summary>
            replaces a variable value
            </summary>
            <param name="name">name of variable</param>
            <param name="value">value to write</param>
        </member>
        <member name="P:Pooshit.Scripting.Parser.VariableProvider.Values">
            <summary>
            access to value lookup
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.GetVariable(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.ContainsVariable(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.ContainsVariableInHierarchy(System.String)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Parser.VariableProvider.GetProvider(System.String)">
            <summary>
            get provider in chain which contains a variable with the specified name
            </summary>
            <param name="variable">name of variable to check for</param>
            <returns>this if this provider contains this variable, null otherwise</returns>
        </member>
        <member name="P:Pooshit.Scripting.Parser.VariableProvider.Variables">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Providers.FileMethodProvider">
            <summary>
            provides external methods from a file path
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Providers.FileMethodProvider.#ctor(Pooshit.Scripting.Parser.IScriptParser)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Providers.FileMethodProvider"/>
            </summary>
            <param name="scriptparser">parser used to parse and compile script code</param>
        </member>
        <member name="M:Pooshit.Scripting.Providers.FileMethodProvider.Import(System.Object[])">
            <summary>
            loads a script from a file to provide an external method
            </summary>
            <param name="parameters">path to scriptfile to load and compile</param>
            <returns>compiled script as a external method</returns>
        </member>
        <member name="T:Pooshit.Scripting.Providers.IImportProvider">
            <summary>
            interface for an external method provider
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Providers.IImportProvider.Import(System.Object[])">
            <summary>
            imports a method or type using the specified argument
            </summary>
            <param name="parameters">parameters for import</param>
            <returns>type loaded from parameters</returns>
        </member>
        <member name="T:Pooshit.Scripting.Providers.LambdaMethod">
            <summary>
            lambda method which can get executed
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Providers.LambdaMethod.#ctor(System.String[],Pooshit.Scripting.ScriptContext,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Providers.LambdaMethod"/>
            </summary>
            <param name="parameters">parameters to use for lambda</param>
            <param name="context">execution context</param>
            <param name="expression">expression to execute</param>
        </member>
        <member name="M:Pooshit.Scripting.Providers.LambdaMethod.Invoke(System.Object[])">
            <summary>
            invokes the method
            </summary>
            <param name="arguments">arguments for lamda</param>
            <returns>execution result</returns>
        </member>
        <member name="T:Pooshit.Scripting.Providers.ResourceScriptMethodProvider">
            <summary>
            provides script methods from assembly resources
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Providers.ResourceScriptMethodProvider.#ctor(System.Reflection.Assembly,Pooshit.Scripting.Parser.IScriptParser)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Providers.ResourceScriptMethodProvider"/>
            </summary>
            <param name="assembly">assembly from which to get script resources</param>
            <param name="parser">parser used to parse and compile scripts</param>
        </member>
        <member name="M:Pooshit.Scripting.Providers.ResourceScriptMethodProvider.Import(System.Object[])">
            <summary>
            imports an external script method assembly resources
            </summary>
            <param name="parameters">resource name</param>
            <returns>script method stored in resource</returns>
        </member>
        <member name="T:Pooshit.Scripting.Providers.TypeInstanceProvider">
            <summary>
            provides instances of arbitrary types
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Providers.TypeInstanceProvider.#ctor(System.Type,Pooshit.Scripting.Parser.Resolvers.IMethodResolver)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Providers.TypeInstanceProvider"/>
            </summary>
            <param name="type">type to create</param>
            <param name="resolver">used to resolve constructor when creating types</param>
        </member>
        <member name="P:Pooshit.Scripting.Providers.TypeInstanceProvider.ProvidedType">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Providers.TypeInstanceProvider.Create(Pooshit.Scripting.Tokens.IScriptToken[],Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Providers.TypeInstanceProvider.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Script">
            <summary>
            script parsed by <see cref="T:Pooshit.Scripting.Parser.ScriptParser"/>
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Script.#ctor(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.Parser.ITypeProvider)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Script"/>
            </summary>
            <param name="script">root token of script to be executed</param>
            <param name="typeprovider">access to installed types</param>
        </member>
        <member name="M:Pooshit.Scripting.Script.ExecuteAsync``1(System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Script.ExecuteAsync``1(Pooshit.Scripting.Parser.IVariableProvider,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Script.Body">
            <summary>
            script body
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Script.Execute(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Script.Execute(Pooshit.Scripting.Parser.IVariableProvider)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Script.Execute``1(System.Collections.Generic.IDictionary{System.String,System.Object})">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Script.ExecuteAsync(System.Collections.Generic.IDictionary{System.String,System.Object},System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Script.ExecuteAsync(Pooshit.Scripting.Parser.IVariableProvider,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Script.Execute``1(Pooshit.Scripting.Parser.IVariableProvider)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.ScriptContext">
            <summary>
            context for script execution
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.ScriptContext.#ctor(Pooshit.Scripting.ScriptContext)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.ScriptContext"/>
            </summary>
            <param name="context">context to base this context on</param>
        </member>
        <member name="M:Pooshit.Scripting.ScriptContext.#ctor(Pooshit.Scripting.Parser.IVariableProvider,Pooshit.Scripting.Parser.ITypeProvider)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.ScriptContext"/>
            </summary>
            <param name="arguments">arguments provided at runtime</param>
            <param name="typeprovider">access to available types</param>
        </member>
        <member name="M:Pooshit.Scripting.ScriptContext.#ctor(Pooshit.Scripting.Parser.IVariableProvider,Pooshit.Scripting.Parser.ITypeProvider,System.Threading.CancellationToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.ScriptContext"/>
            </summary>
            <param name="arguments">arguments provided at runtime</param>
            <param name="typeprovider">access to available types</param>
            <param name="cancellationToken">cancellation token used to abort script execution (optional)</param>
        </member>
        <member name="P:Pooshit.Scripting.ScriptContext.Arguments">
            <summary>
            arguments provided at runtime
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.ScriptContext.TypeProvider">
            <summary>
            provider for known type information
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.ScriptContext.CancellationToken">
            <summary>
            cancellation token used to abort script execution
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ArithmeticBlock">
            <summary>
            block containing an arithmetic evaluation
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ArithmeticBlock.InnerBlock">
            <summary>
            inner statement block
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ArithmeticBlock.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ArithmeticBlock.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ArithmeticBlock.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.Await">
            <summary>
            await token used to await async tasks
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Await.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.Await"/> token
            </summary>
            <param name="token">token resulting in task to be awaited</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Await.Task">
            <summary>
            task to be awaited
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Await.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Await.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Await.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Await.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Await.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.Comment">
            <summary>
            token containing comment for a script section
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Comment.#ctor(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.Comment"/>
            </summary>
            <param name="text">text to include</param>
            <param name="textindex">text index where comment is stored</param>
            <param name="isMultiline">determines whether comment is multiline</param>
            <param name="linenumber">line number where comment is stored</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Comment.IsMultiline">
            <summary>
            determines whether comment is multiline
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Comment.IsPostComment">
            <summary>
            determines whether comment is appended to previous token (only valid for single line comments)
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Comment.Literal">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Comment.Text">
            <summary>
            comment text
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Comment.Execute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Comment.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Comment.LineNumber">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Comment.TextIndex">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Comment.TokenLength">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.DictionaryToken">
            <summary>
            token resulting in a dictionary
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.DictionaryToken.Add(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            adds an entry to the dictionary
            </summary>
            <param name="key">token resulting in dictionary key</param>
            <param name="value">token resulting in dictionary value</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.DictionaryToken.Entries">
            <summary>
            entries in dictionary
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.DictionaryToken.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.DictionaryToken.Execute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ExpliciteTypeCast">
            <summary>
            explicitely casts a value to another type
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ExpliciteTypeCast.#ctor(Pooshit.Scripting.Parser.ITypeProvider,Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.Tokens.ScriptValue,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates an <see cref="T:Pooshit.Scripting.Tokens.ExpliciteTypeCast"/>
            </summary>
            <param name="typeprovider">type provider used to get type</param>
            <param name="value">value to cast</param>
            <param name="targetType">target type to cast to</param>
            <param name="isdynamic">determines whether to execute a dynamic cast</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ExpliciteTypeCast.TypeProvider">
            <summary>
            type provider used to resolve type
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ExpliciteTypeCast.Value">
            <summary>
            value to cast
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ExpliciteTypeCast.TargetType">
            <summary>
            type to cast value to
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ExpliciteTypeCast.IsDynamic">
            <summary>
            whether this is a dynamic cast
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ExpliciteTypeCast.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ExpliciteTypeCast.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ExpliciteTypeCast.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ExpliciteTypeCast.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ICodePositionToken">
            <summary>
            token which contains information about its position in original source code
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ICodePositionToken.LineNumber">
            <summary>
            line number where token is stored
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ICodePositionToken.TextIndex">
            <summary>
            index in text where token starts
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ICodePositionToken.TokenLength">
            <summary>
            length of token in code
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ImpliciteTypeCast">
            <summary>
            changes the type of an expression result
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ImpliciteTypeCast.#ctor(System.String,System.Type,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ImpliciteTypeCast"/>
            </summary>
            <param name="keyword">keyword used in script when casting</param>
            <param name="targettype">target type</param>
            <param name="token">token resulting in value to cast</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ImpliciteTypeCast.Keyword">
            <summary>
            keyword used for cast
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ImpliciteTypeCast.TargetType">
            <summary>
            type to cast argument to
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ImpliciteTypeCast.Argument">
            <summary>
            argument to cast
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ImpliciteTypeCast.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ImpliciteTypeCast.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.IParameterContainer">
            <summary>
            control token which is based on a condition
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.IParameterContainer.Parameters">
            <summary>
            evaluated condition
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.IParameterContainer.ParametersOptional">
            <summary>
            determines whether specification of parameters is optional
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Tokens.IScriptToken">
            <summary>
            token of a script which can get executed
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.IScriptToken.Literal">
            <summary>
            literal which identify the token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.IScriptToken.Execute(Pooshit.Scripting.ScriptContext)">
            <summary>
            executes the token returning a result
            </summary>
            <returns>result of token call</returns>
        </member>
        <member name="T:Pooshit.Scripting.Tokens.LambdaToken">
            <summary>
            token which provides a <see cref="T:Pooshit.Scripting.Providers.LambdaMethod"/>
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.LambdaToken.Literal">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.LambdaToken.Lhs">
            <summary>
            parameters for lambda method
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.LambdaToken.Rhs">
            <summary>
            expression to execute
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.LambdaToken.Execute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.LambdaToken.Operator">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.NewInstance">
            <summary>
            creates a new instance of a type
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.NewInstance.#ctor(System.String,System.Type,Pooshit.Scripting.Parser.ITypeInstanceProvider,Pooshit.Scripting.Tokens.IScriptToken[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.NewInstance"/>
            </summary>
            <param name="typename">name of type to instanciate like specified in code</param>
            <param name="type">type information to instanciate</param>
            <param name="provider">type provider to use</param>
            <param name="parameters">parameters for constructor</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.NewInstance.TypeName">
            <summary>
            name of type in script
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.NewInstance.Type">
            <summary>
            type to be created (just an indicator for reflection)
            </summary>
            <remarks>
            when in doubt use typeof(object)
            </remarks>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.NewInstance.Initializer">
            <summary>
            initializer used to set initial properties of object
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.NewInstance.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.NewInstance.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.NewInstance.ToString">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.NewInstance.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.NewInstance.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.NewLine">
            <summary>
            token containing an empty line for human formatting purposes
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.NewLine.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.NewLine.Execute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.NewLine.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.Reference">
            <summary>
            a reference to an assignable token
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Reference.#ctor(Pooshit.Scripting.Operations.IAssignableToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.Reference"/>
            </summary>
            <param name="argument">argument to use as reference parameter</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.Reference.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Reference.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.Reference.Assign(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ReferenceParameter">
            <summary>
            parameter to use in a reference call
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ReferenceParameter.#ctor(System.Int32,Pooshit.Scripting.Operations.IAssignableToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ReferenceParameter"/>
            </summary>
            <param name="index">index of parameter</param>
            <param name="variable">variable to write parameter value to after call</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ReferenceParameter.Index">
            <summary>
            index of parameter
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ReferenceParameter.Variable">
            <summary>
            variable to write parameter value to after call
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptArray">
            <summary>
            token which represents multiple values
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptArray.#ctor(Pooshit.Scripting.Tokens.IScriptToken[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ScriptArray"/>
            </summary>
            <param name="values">values in array</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptArray.Values">
            <summary>
            values contained in array
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptArray.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptArray.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptArray.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptIndexer">
            <summary>
            indexer call on an object
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptIndexer.#ctor(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.Tokens.IScriptToken[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ScriptIndexer"/>
            </summary>
            <param name="hosttoken">token representing host</param>
            <param name="parameters">parameters for indexer call</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptIndexer.Host">
            <summary>
            host to call indexer on
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptIndexer.NightlyCode#Scripting#Tokens#IParameterContainer#Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptIndexer.Parameters">
            <summary>
            access to parameters of indexer
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptIndexer.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptIndexer.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptIndexer.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptIndexer.AssignToken(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptIndexer.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptMember">
            <summary>
            reads a value from a host member
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptMember.#ctor(Pooshit.Scripting.Tokens.IScriptToken,System.String)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ScriptMember"/>
            </summary>
            <param name="host">host of member</param>
            <param name="membername">name of member to read</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMember.Host">
            <summary>
            instance of which member is served
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMember.Member">
            <summary>
            name of member
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMember.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptMember.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptMember.AssignToken(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptMember.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptMethod">
            <summary>
            calls a method in a script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptMethod.#ctor(Pooshit.Scripting.Parser.Resolvers.IMethodResolver,Pooshit.Scripting.Tokens.IScriptToken,System.String,Pooshit.Scripting.Tokens.IScriptToken[],Pooshit.Scripting.Tokens.IScriptToken[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ScriptMethod"/>
            </summary>
            <param name="resolver">resolves method calls</param>
            <param name="hosttoken">host of method to be called</param>
            <param name="methodname">name of method to call</param>
            <param name="parameters">parameters for method call</param>
            <param name="genericparameters">generic parameters used for generic method templates</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMethod.Host">
            <summary>
            host to call method on
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMethod.MethodName">
            <summary>
            name of method to call
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMethod.NightlyCode#Scripting#Tokens#IParameterContainer#Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMethod.Parameters">
            <summary>
            direct access to parameters for this method call
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMethod.GenericParameters">
            <summary>
            generic parameters for generic method templates
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMethod.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptMethod.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptMethod.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptMethod.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptParameter">
            <summary>
            token used to specify type of a parameter
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptParameter.#ctor(Pooshit.Scripting.Parser.ITypeProvider,Pooshit.Scripting.Tokens.ScriptVariable,Pooshit.Scripting.Tokens.TypeToken,Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ScriptParameter"/>
            </summary>
            <param name="typeProvider">provider used to resolve type name</param>
            <param name="variable">parameter variable</param>
            <param name="type">value which expresses the parameter type</param>
            <param name="defaultvalue">default value to use when parameter value is not provided</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptParameter.TypeProvider">
            <summary>
            type provider used to resolve type
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptParameter.Variable">
            <summary>
            parameter value
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptParameter.Type">
            <summary>
            type parameter is forced to
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptParameter.DefaultValue">
            <summary>
            default value when parameter value is not provided
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptParameter.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptParameter.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptParameter.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptParameter.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptToken">
            <summary>
            base implementation of a script token with basic error handling
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptToken.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptToken.Execute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptToken.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <summary>
            evaluates the result of the token
            </summary>
            <returns>result of statement</returns>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptToken.LineNumber">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptToken.TextIndex">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptToken.TokenLength">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptToken.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptValue">
            <summary>
            value in a script command
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptValue.#ctor(System.Object)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Parser.ScriptParser"/>
            </summary>
            <param name="value">value</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptValue.Value">
            <summary>
            contained value
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptValue.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptValue.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptValue.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.ScriptVariable">
            <summary>
            access to variable in script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptVariable.#ctor(System.String)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.ScriptVariable"/>
            </summary>
            <param name="name">name of variable</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptVariable.Name">
            <summary>
            name of variable
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.ScriptVariable.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptVariable.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptVariable.AssignToken(Pooshit.Scripting.Tokens.IScriptToken,Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.ScriptVariable.ToString">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.StringInterpolation">
            <summary>
            interpolates tokens to a string
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.StringInterpolation.#ctor(Pooshit.Scripting.Tokens.IScriptToken[])">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.StringInterpolation"/>
            </summary>
            <param name="tokens">tokens to interpolate</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.StringInterpolation.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.StringInterpolation.Execute(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.StringInterpolation.Children">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.TypeOfToken">
            <summary>
            extracts type of an expression
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.TypeOfToken.#ctor(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.TypeOfToken"/>
            </summary>
            <param name="token">token to be analysed</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.TypeOfToken.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.TypeOfToken.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.TypeOfToken.Parameters">
            <inheritdoc />
        </member>
        <member name="P:Pooshit.Scripting.Tokens.TypeOfToken.ParametersOptional">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Tokens.TypeToken">
            <summary>
            token used to provide type information
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Tokens.TypeToken.#ctor(System.Type)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Tokens.TypeToken"/>
            </summary>
            <param name="type">type provided by token</param>
        </member>
        <member name="P:Pooshit.Scripting.Tokens.TypeToken.Literal">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Tokens.TypeToken.ExecuteToken(Pooshit.Scripting.ScriptContext)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Visitors.IScriptVisitor">
            <summary>
            visits every token of a script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.IScriptVisitor.Visit(Pooshit.Scripting.IScript)">
            <summary>
            traverses a script
            </summary>
            <param name="script"></param>
        </member>
        <member name="T:Pooshit.Scripting.Visitors.MetricVisitor">
            <summary>
            visits a script to determine metrics
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.MetricVisitor.Variables">
            <summary>
            number of variables
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.MetricVisitor.ControlTokens">
            <summary>
            number of control tokens
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.MetricVisitor.FlowTokens">
            <summary>
            number of flow tokens
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.MetricVisitor.Imports">
            <summary>
            number of imports
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.MetricVisitor.TypeCasts">
            <summary>
            number of type casts
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.MetricVisitor.NewInstances">
            <summary>
            number of type creations
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitNew(Pooshit.Scripting.Tokens.NewInstance)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitTypeCast(Pooshit.Scripting.Tokens.ImpliciteTypeCast)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitImport(Pooshit.Scripting.Control.Import)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.Visit(Pooshit.Scripting.IScript)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitWait(Pooshit.Scripting.Control.Wait)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitThrow(Pooshit.Scripting.Control.Throw)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitReturn(Pooshit.Scripting.Control.Return)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitContinue(Pooshit.Scripting.Control.Continue)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitBreak(Pooshit.Scripting.Control.Break)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitVariable(Pooshit.Scripting.Tokens.ScriptVariable)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.MetricVisitor.VisitControlToken(Pooshit.Scripting.Control.IStatementContainer)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Visitors.ParameterExtractor">
            <summary>
            extracts parameters from a script which are not provided by the script itself
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.ParameterExtractor.Parameters">
            <summary>
            detected parameters
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ParameterExtractor.Visit(Pooshit.Scripting.IScript)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ParameterExtractor.VisitScriptParameter(Pooshit.Scripting.Tokens.ScriptParameter)">
            <inheritdoc />
        </member>
        <member name="T:Pooshit.Scripting.Visitors.ParameterInfo">
            <summary>
            info about a parameter in script
            </summary>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ParameterInfo.#ctor(System.String,System.Boolean)">
            <summary>
            creates a new <see cref="T:Pooshit.Scripting.Visitors.ParameterInfo"/>
            </summary>
            <param name="name">name of paramter</param>
            <param name="isOptional">determines whether parameter needs to be specified for script to work</param>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.ParameterInfo.Name">
            <summary>
            name of parameter
            </summary>
        </member>
        <member name="P:Pooshit.Scripting.Visitors.ParameterInfo.IsOptional">
            <summary>
            determines whether the parameter has a default value
            </summary>
        </member>
        <member name="T:Pooshit.Scripting.Visitors.ScriptVisitor">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.Visit(Pooshit.Scripting.IScript)">
            <inheritdoc />
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitToken(Pooshit.Scripting.Tokens.IScriptToken)">
            <summary>
            visits any token in a script
            </summary>
            <param name="token">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitExplicitTypeCast(Pooshit.Scripting.Tokens.ExpliciteTypeCast)">
            <summary>
            visits an explicit type cast
            </summary>
            <param name="explicittypecast">type cast token</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitScriptParameter(Pooshit.Scripting.Tokens.ScriptParameter)">
            <summary>
            visits a script parameter declaration
            </summary>
            <param name="parameter">script parameter token</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitAwait(Pooshit.Scripting.Tokens.Await)">
            <summary>
            visits an await token
            </summary>
            <param name="awaittoken">await token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitDictionary(Pooshit.Scripting.Tokens.DictionaryToken)">
            <summary>
            visits a dictionary token
            </summary>
            <param name="dictionary">dictionary to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitMember(Pooshit.Scripting.Tokens.ScriptMember)">
            <summary>
            visits a member of a host
            </summary>
            <param name="member">member to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitArray(Pooshit.Scripting.Tokens.ScriptArray)">
            <summary>
            visits an array
            </summary>
            <param name="array">array to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitArithmeticBlock(Pooshit.Scripting.Tokens.ArithmeticBlock)">
            <summary>
            visits an arithmetic block
            </summary>
            <param name="arithmeticblock">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitMethod(Pooshit.Scripting.Tokens.ScriptMethod)">
            <summary>
            visits a indexer token
            </summary>
            <param name="method">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitIndexer(Pooshit.Scripting.Tokens.ScriptIndexer)">
            <summary>
            visits a indexer token
            </summary>
            <param name="indexer">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitUnary(Pooshit.Scripting.Operations.IUnaryToken)">
            <summary>
            visits an unary token
            </summary>
            <param name="unary"></param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitBinaryToken(Pooshit.Scripting.Operations.IBinaryToken)">
            <summary>
            visits a binary token
            </summary>
            <param name="binary">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitNew(Pooshit.Scripting.Tokens.NewInstance)">
            <summary>
            visits a new token
            </summary>
            <param name="newinstance">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitImport(Pooshit.Scripting.Control.Import)">
            <summary>
            visits a import token
            </summary>
            <param name="import">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitTypeCast(Pooshit.Scripting.Tokens.ImpliciteTypeCast)">
            <summary>
            visits a type cast token
            </summary>
            <param name="typecast">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitWait(Pooshit.Scripting.Control.Wait)">
            <summary>
            visits a wait token
            </summary>
            <param name="wait">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitThrow(Pooshit.Scripting.Control.Throw)">
            <summary>
            visits a throw token
            </summary>
            <param name="throw">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitReturn(Pooshit.Scripting.Control.Return)">
            <summary>
            visits a return token
            </summary>
            <param name="return">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitContinue(Pooshit.Scripting.Control.Continue)">
            <summary>
            visits a continue token
            </summary>
            <param name="continue">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitBreak(Pooshit.Scripting.Control.Break)">
            <summary>
            visits a break token
            </summary>
            <param name="break">token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitContainer(Pooshit.Scripting.Control.ITokenContainer)">
            <summary>
            visits a statement block in a script
            </summary>
            <param name="container">container to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitVariable(Pooshit.Scripting.Tokens.ScriptVariable)">
            <summary>
            visits a variable in a script
            </summary>
            <param name="variable">script variable</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitParameterContainer(Pooshit.Scripting.Tokens.IParameterContainer)">
            <summary>
            visits a parameter container
            </summary>
            <param name="parametercontainer">token which takes parameters for execution</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitControlToken(Pooshit.Scripting.Control.IStatementContainer)">
            <summary>
            visits a control token
            </summary>
            <param name="controltoken">control token to visit</param>
        </member>
        <member name="M:Pooshit.Scripting.Visitors.ScriptVisitor.VisitParameters(Pooshit.Scripting.Tokens.IParameterContainer)">
            <summary>
            visits parameters of a token
            </summary>
            <param name="token">control token to visit</param>
        </member>
    </members>
</doc>
